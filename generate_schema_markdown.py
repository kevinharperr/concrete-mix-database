"""Generate a comprehensive Markdown documentation of the Django database schema.

The script introspects all installed Django models, extracts their fields, constraints,
and relationship information, and writes everything into a Markdown file similar to
`cdb_database_dictionary.md` but more exhaustive.  Run it with:

    python generate_schema_markdown.py [output_path]

If `output_path` is omitted, the documentation will be written to
`cdb_database_dictionary_generated.md` in the project root.
"""
from __future__ import annotations

import os
import sys
from typing import List, Tuple, Union, Optional

import django
from django.apps import apps
from django.core.management.color import no_style
from django.db import connection, models
from django.utils.text import slugify

# ---------------------------------------------------------------------------
# Initialise Django
# ---------------------------------------------------------------------------

PROJECT_SETTINGS = os.environ.get("DJANGO_SETTINGS_MODULE", "concrete_mix_project.settings")
os.environ.setdefault("DJANGO_SETTINGS_MODULE", PROJECT_SETTINGS)

django.setup()

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def bold(text: str) -> str:
    """Return **bold** Markdown text."""
    return f"**{text}**"


def code(text: str) -> str:
    """Return `code` Markdown text."""
    return f"`{text}`"


def human_field_type(field: models.Field) -> str:
    """Provide a human-readable description of a Django field type."""
    field_type = type(field).__name__
    # Add max_length / decimal specifics when available
    if isinstance(field, models.CharField):
        return f"CharField({field.max_length})"
    if isinstance(field, models.DecimalField):
        return f"DecimalField({field.max_digits}, {field.decimal_places})"
    if isinstance(field, models.ForeignKey):
        return f"ForeignKey → {field.related_model.__name__}"
    if isinstance(field, models.OneToOneField):
        return f"OneToOne → {field.related_model.__name__}"
    if isinstance(field, models.ManyToManyField):
        return f"ManyToMany → {field.related_model.__name__}"
    return field_type


def describe_field(field: models.Field) -> List[str]:
    """Return a list of string values for the Markdown table row of a field."""
    default_repr: str
    if field.has_default():
        default_value = field.default
        default_repr = repr(default_value() if callable(default_value) else default_value)
    else:
        default_repr = "—"
    return [
        code(field.name),
        human_field_type(field),
        "✓" if field.null else "—",
        "✓" if field.primary_key else "—",
        "✓" if field.unique else "—",
        default_repr,
        str(field.help_text) if field.help_text else "",
    ]


def emit_table(headers: List[str], rows: List[List[str]]) -> str:
    """Return a GitHub-flavoured Markdown table."""
    header_line = " | ".join(headers)
    separator = " | ".join(["---"] * len(headers))
    body = "\n".join(" | ".join(row) for row in rows)
    return f"{header_line}\n{separator}\n{body}\n"


def generate_schema_markdown() -> str:
    """Generate the full Markdown documentation and return as string."""
    md_lines: List[str] = []

    title = "# Concrete Mix Database – Auto-Generated Schema Documentation"
    md_lines.append(title)
    md_lines.append("\nGenerated by `generate_schema_markdown.py`. Do **not** edit by hand.\n")

    # Intro
    md_lines.append("This document enumerates every Django model, its database table, fields, and relationships.\n")

    # Loop over all models, ordered by app label and model name for consistency
    for model in sorted(apps.get_models(), key=lambda m: f"{m._meta.app_label}.{m.__name__}"):
        meta = model._meta
        model_header = f"## {model.__name__} ({code(meta.db_table)})"
        md_lines.append("\n" + model_header + "\n")

        # Count rows (may fail if table missing), ignore errors in migrations
        try:
            row_count = model.objects.count()
            md_lines.append(f"Records: {row_count}")
        except Exception:  # pragma: no cover – e.g. during initial migrate
            md_lines.append("Records: — (table not available)")
        md_lines.append("")

        # Fields table
        field_headers = [
            bold("Column"), bold("Type"), bold("Null"), bold("PK"), bold("Unique"), bold("Default"), bold("Notes")
        ]
        field_rows: List[List[str]] = []
        for field in meta.get_fields():
            # Only include database-backed fields (exclude reverse and M2M relations on other side)
            if not hasattr(field, "column") or field.auto_created and not field.concrete:
                continue
            field_rows.append(describe_field(field))

        md_lines.append(emit_table(field_headers, field_rows))

        # Relationships
        rel_lines: List[str] = []
        for field in meta.get_fields():
            if isinstance(field, (models.ForeignKey, models.OneToOneField)):
                rel_lines.append(f"- {code(field.name)} → {field.related_model.__name__} `{field.related_model._meta.db_table}` (FK)")
            elif isinstance(field, models.ManyToManyField):
                through = field.remote_field.through
                rel_lines.append(
                    f"- {code(field.name)} ↔ {field.related_model.__name__} via `{through._meta.db_table}` (M2M)"
                )
        if rel_lines:
            md_lines.append("**Relationships**\n")
            md_lines.extend(rel_lines)
            md_lines.append("")

        # Model-level options: unique_together, indexes
        if meta.unique_together:
            md_lines.append("**Unique constraints**\n")
            for ut in meta.unique_together:
                cols = ", ".join(code(c) for c in ut)
                md_lines.append(f"- ({cols})")
            md_lines.append("")
        if meta.indexes:
            md_lines.append("**Indexes**\n")
            for idx in meta.indexes:
                md_lines.append(f"- {', '.join(code(f) for f in idx.fields)} ({idx.__class__.__name__})")
            md_lines.append("")

    return "\n".join(md_lines)


# ---------------------------------------------------------------------------
# CLI entry-point
# ---------------------------------------------------------------------------

def main(argv: List[str] | None = None) -> None:
    argv = argv or sys.argv[1:]
    output_path: str
    if argv:
        output_path = argv[0]
    else:
        output_path = os.path.join(os.path.dirname(__file__), "cdb_database_dictionary_generated.md")

    markdown_content = generate_schema_markdown()
    with open(output_path, "w", encoding="utf-8") as fh:
        fh.write(markdown_content)

    print(f"Database schema documentation written to: {output_path}")


if __name__ == "__main__":
    main()
